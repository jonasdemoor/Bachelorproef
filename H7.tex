
%%=============================================================================
%% H7 - ZFS Datasets
%%=============================================================================

\chapter{ZFS Datasets}
\label{ch:h7}

In dit hoofdstuk worden ZFS datasets of bestandssystemen besproken. Er wordt onder andere getoond hoe men bestandssystemen kan aanmaken, wijzigen en delen met andere computers op het netwerk. 

\section{Verschillen met traditionele bestandssystemen}

In essentie verschillen datasets (of bestandssystemen) binnen ZFS niet zo heel veel van andere, "traditionele" bestandssystemen. Een dataset is in principe een verzameling van data dat een bepaalde naam heeft; deze dataset vormt een logische eenheid van beheer. Dit komt grotendeels overeen met partities bij andere bestandssystemen, waarbij een (deel van) een schijf wordt gereserveerd voor een bepaald type gebruik (zoals gebruikersmappen) \autocite{Lucas2015}.

Toch zijn er een aantal grote verschillen, zoals bijvoorbeeld de manier waarop er omgegaan wordt met beschikbare schijfruimte.  

\subsection{Gebruik van de beschikbare opslagcapaciteit}

Een groot verschil tussen bestandssystemen bij ZFS en vele andere bestandssystemen, is dat ZFS datasets gebruik maken van de voordelen van storage pools. ZFS legt bijna geen limieten op aan de grootte van bestandssystemen; de enige limiet die aan de grootte van bestandssystemen wordt opgelegd, is de grootte van de storage pool. Dit is een groot verschil met traditionele bestandssystemen: alvorens een partitie aan te maken en te formatteren, moet de systeembeheerder eerst nadenken over de grootte en lay-out van deze partitie en van de rest van de schijf of schijven. Na deze beslissingen genomen te hebben, maakt de gebruiker deze partitie aan. \autocite{Lucas2015}.

Standaard neemt een ZFS dataset de ruimte van een pool in die het nodig heeft; de systeembeheerder moet zich dus niet bezighouden met het vooraf instellen van de grootte van een dataset. Het is echter wel mogelijk om de groei van een dataset tegen te gaan d.m.v. quota's en reservaties \autocite{FBSDDP2017}; het gebruik van ZFS properties op datasets komt later in dit hoofdstuk nog aan bod. 

\subsection{Verschillende types van datasets}

Een dataset kan binnen ZFS een aantal vormen aannemen. Eén van de meest voorkomende vormen van een dataset is een \textbf{file system} of bestandssysteem: dit is het equivalent van een klassiek bestandssysteem, met bestanden, mappen, permissies enzovoorts. Daarnaast bestaan er nog andere datasettypes, zoals snapshots, clones, volumes (of zvols) en bookmarks \autocite{Lucas2015}. Deze verschillende types zullen iets uitgebreider worden besproken in de volgende sectie.  

\subsection{Hiërarchische structuur van ZFS datasets}

Datasets worden - net zoals zpools - binnen ZFS voorgesteld als objecten, met elk bepaalde eigenschappen (of properties). Traditionele bestandssystemen hebben ook bepaalde eigenschappen die kunnen veranderd worden, maar ZFS gaat hier nog een stap verder in. Net zoals bij VDEV's worden datasets voorgesteld in een boomstructuur: elke dataset heeft een ouder en eventueel kinderen. Dit maakt het mogelijk om overerving toe te passen op datasets; hierbij erven de kinderen van een bepaalde dataset de properties over van hun ouder \autocite{FBSDDP2017}.

Datasets maken het voor de systeembeheerder makkelijk om verschillende soorten data van elkaar te scheiden; op deze datasets kunnen dan bepaalde properties worden ingesteld m.b.t. bijvoorbeeld gebruikersrechten. Met behulp van ouder-kind relaties tussen datasets kunnen zowel algemene eigenschappen als meer specifieke eigenschappen worden ingesteld. Er kan bijvoorbeeld een dataset worden aangemaakt voor een project; deze beschikt dan over algemene eigenschappen, zoals toegangsrechten voor de verschillende teams die aan het project werken. Binnen deze ouder-dataset kunnen kind-datasets worden aangemaakt met meer specifieke eigenschapppen; elke dataset behoort bijvoorbeeld toe aan een specifiek team en heeft dan ook eigenschappen die uniek zijn voor dat bepaald team, bovenop de reeds overgeërfde eigenschappen van de ouder-dataset (voorbeeld naar \textcite{Lucas2015}).

\section{Aanmaken \& beheren van ZFS datasets}

Voor het beheer van datasets wordt het commando \texttt{zfs} gebruikt; de syntax komt grotendeels overeen met die van \texttt{zpool}, het commando om ZFS pools te beheren. 

Als vertrekpunt wordt er een zpool gebruikt bestaande uit één RAID-Z1 VDEV en drie fysieke VDEV's:

\begin{lstlisting}[language=bash,style=command_style]
  $ zpool create storage raidz1 /dev/sda /dev/sdb /dev/sdc
  $ zpool status
    pool: storage
   state: ONLINE
    scan: none requested
  config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1-0  ONLINE       0     0     0
	    sda     ONLINE       0     0     0
	    sdb     ONLINE       0     0     0
	    sdc     ONLINE       0     0     0

  errors: No known data errors
\end{lstlisting}

\subsection{Bekijken en aanmaken van datasets}

Om de huidige aanwezige datasets te bekijken, gebruik je het commando \texttt{zfs list}:

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs list
  NAME      USED  AVAIL  REFER  MOUNTPOINT
  storage   464K   898G   128K  /storage
\end{lstlisting}

In dit geval is er reeds automatisch een dataset aangemaakt met de naam 'storage' en als mountpoint '/storage'. Deze heeft dezelde naam als de zpool: deze is dus m.a.w. de parent dataset van alle andere datasets die binnen deze pool zullen worden aangemaakt.

Er kan ook een lijst worden opgevraagd van alle aangekoppelde (\textit{mounted}) bestandssystemen m.b.v. het UNIX-commando \texttt{df}:

\begin{lstlisting}[language=bash,style=command_style] 
  $ df -h
  Filesystem               Size  Used Avail Use% Mounted on
  devtmpfs                 4.9G     0  4.9G   0% /dev
  tmpfs                    4.9G     0  4.9G   0% /dev/shm
  tmpfs                    4.9G  920K  4.9G   1% /run
  tmpfs                    4.9G     0  4.9G   0% /sys/fs/cgroup
  /dev/mapper/fedora-root   15G  1.8G   14G  12% /
  tmpfs                    4.9G  4.0K  4.9G   1% /tmp
  /dev/sdd1                976M  138M  772M  16% /boot
  tmpfs                    993M     0  993M   0% /run/user/1000
  storage                  899G  128K  899G   1% /storage 
\end{lstlisting}

Zoals kan worden afgeleid uit de uitvoer van bovenstaand commando, is de ZFS dataset inderdaad gekoppeld aan de map \texttt{/storage}.

Om binnen de dataset \texttt{storage} een nieuwe dataset aan te maken, gebruik je het commando \texttt{zfs create}. Met behulp van dit commando kunnen er verschillende soorten ZFS datasets worden aangemaakt. Hieronder volgt een overzicht van de verschillende soorten datasets en hoe deze kunnen worden ingezet.

\subsubsection{Filesystems}

Filesystems (of bestandssystemen) zijn de meest voorkomende datasettypes. Qua eigenschappen en werking komen ze overeen met traditionele bestandssystemen: beide dienen om bestanden en mappen op te slaan, bevatten een POSIX-achtig permissiemodel en inodes \autocite{Lucas2015}. 

Om het voorgaande voorbeeld van de verschillende teams met verschillende projecten wat te illustreren, maken we onder de root dataset \texttt{/storage} de dataset \texttt{/storage/projects} aan. Daarna worden de andere datasets aangemaakt onder de parent \texttt{/storage/projects}.

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs create storage/projects
  $ zfs create storage/projects/www
  $ zfs create storage/projects/dev
  $ zfs list
  NAME                   USED  AVAIL  REFER  MOUNTPOINT
  storage                767K   898G   133K  /storage
  storage/projects       394K   898G   139K  /storage/projects
  storage/projects/dev   128K   898G   128K  /storage/projects/dev
  storage/projects/www   128K   898G   128K  /storage/projects/www
\end{lstlisting}

Uit de uitvoer van \texttt{zfs list} kan men de makkelijk de ouder-kindrelaties opmaken: \texttt{storage} is de ouder van projects en projects is op zijn beurt opnieuw ouder van \texttt{dev} en \texttt{www}.

\subsubsection{Volumes}

ZFS volumes (of zvols) zijn het equivalent van UNIX block devices en worden dan ook als block devices voorgesteld; zvols bevinden zich onder de map \texttt{/dev/zvol}. In deze situatie doet ZFS zich voor als een soort van volume manager: de zvols worden door gebruikers en applicaties gezien als een normale schijf. Bovenop deze ZFS volumes kunnen dan andere bestandssystemen (zoals EXT4) worden aangemaakt; het grote voordeel hierbij is dat er bovenop de functionaliteiten van het gebruikte bestandssysteem ook eigenschappen van ZFS kunnen worden toegepast. Zo kan er bijvoorbeeld m.b.v. ZFS compressie worden toegepast op bestandssystemen die dit normaal niet ondersteunen (zoals FAT) \autocite{FBSDDP2017}.

\clearpage

Om een ZFS volume aan te maken met een grootte van 20GB en met compressie, gebruik je het volgende commando:

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs create -V 20G -o compression=on storage/projects/vol_test
  & zfs list
  NAME                        USED  AVAIL  REFER  MOUNTPOINT
  storage                    20.6G   877G   133K  /storage
  storage/projects           20.6G   877G   139K  /storage/projects
  storage/projects/dev        128K   877G   128K  /storage/projects/dev
  storage/projects/vol_test  20.6G   898G  85.2K  -
  storage/projects/www        128K   877G   128K  /storage/projects/www
\end{lstlisting}

Een zvol heeft geen mount point, aangezien het om een block device gaat. Om bijvoorbeeld een EXT4 bestandsysteem aan te maken bovenop het volume en het vervolgens aan te koppelen, kan men de volgende procedure volgen:

\begin{lstlisting}[language=bash,style=command_style] 
  $ mkfs.ext4 /dev/zvol/storage/projects/vol_test
  $ mkdir /mnt/zvol_test
  $ mount /dev/zvol/storage/projects/vol_test /mnt/zvol_test/
  $ df -h /mnt/zvol_test/
  Filesystem      Size  Used Avail Use% Mounted on
  /dev/zd0         20G   45M   19G   1% /mnt/zvol_test
\end{lstlisting}

In bovenstaand voorbeeld werd er eerst een EXT4-bestandssysteem aangemaakt op het volume; daarna werd het nodige \textit{mount point} aangemaakt. Vervolgens werd het bestandssysteem aan het aankoppelpunt gekoppeld.  

\subsubsection{Snapshots}

Snapshots zijn \textit{read-only} kopieën van een dataset; deze kunnen gemaakt worden van zowel bestandssystemen als volumes. Dankzij de COW-eigenschappen van ZFS is het triviaal om een snapshot te maken: bij het aanmaken van een snapshot wordt er eerst een kopie gemaakt van de data; deze zal worden blijven gebruikt door het systeem. Bij COW wordt de oude data niet overschreven: het is deze data dat in een snapshot terecht zal komen \autocite{Lucas2015}.

Voordelen van snapshots zijn o.a. dat ze snel kunnen worden aangemaakt en worden teruggezet en dat ze weinig beslag leggen op de beschikbare schijfruimte. Bij creatie worden alle data en metadata van de dataset gedupliceerd d.m.v. referenties te leggen naar de originele dataset. Vanaf het ogenblik dat de brondataset verandert, moeten deze wijzigingen in de snapshot worden bijgehouden. In het begin is dus de grootte van een snapshot gelijk aan die van de dataset waarvan er een kopie gemaakt werd \autocite{FBSDDP2017}.

Een snapshot kan bijvoorbeeld worden gebruikt om een back-up te hebben van de productieomgeving binnen het bedrijf. Als er iets fout is gelopen, kan er makkelijk worden terugerold naar de vorige versie m.b.v. een snapshot. 

Om een snapshot te maken van de dataset \texttt{storage/projects/www}, kan men het volgende commando gebruiken:

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs snapshot storage/projects/www@www_$(date "+%d-%m-%Y")
  $ zfs list -t snapshot
  NAME                                  USED  AVAIL  REFER  MOUNTPOINT
  storage/projects/www@www_16-05-2017      0      -   128K  -
\end{lstlisting}

De '@' is een delimiter; na deze karakter kan een naam worden ingegeven voor de dataset. In bovenstaand voorbeeld wordt de naam van de dataset gekozen gevolgd, door de huidige datum. De optie '-t' bij het commando \texttt{zfs list} wordt gebruikt om enkel bepaalde types van datasets weer te geven.

Er kunnen ook recursieve snapshots worden gemaakt: hierbij worden kind-datasets ook mee opgenomen in een snapshot. Om aan te geven dat er een recursieve snapshot moet worden gecreëerd, wordt de optie '-r' gebruikt.

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs snapshot -r storage@storage_rec_$(date "+%d-%m-%Y")
  $ zfs list -t snapshot
  NAME                                               USED  AVAIL  REFER  MOUNTPOINT
  storage@storage_rec_16-05-2017                        0      -   133K  -
  storage/projects@storage_rec_16-05-2017               0      -   139K  -
  storage/projects/dev@storage_rec_16-05-2017           0      -   128K  -
  storage/projects/vol_test@storage_rec_16-05-2017      0      -  3.43M  -
  storage/projects/www@www_16-05-2017                   0      -   128K  -
  storage/projects/www@storage_rec_16-05-2017           0      -   128K  -
\end{lstlisting}

Hier ziet men inderdaad dat het aanmaken van de snapshot \texttt{storage\_rec\_16-05-2017} recursief gebeurde.

Het gebruik van snapshots komt nog uitgebreid aan bod in Hoofdstuk \ref{ch:h9}: \textit{Data-integriteit en Consistentie bij ZFS}.

\subsubsection{Clones}

Een clone is een kopie van een snapshot dat qua werking overeenkomt met een volwaardig bestandssysteem. De clone en de originele snapshot leven dus naast elkaar; zo is bijvoorbeeld de snapshot de productieomgeving en de clone een kopie van deze omgeving. Dit maakt het mogelijk om aanpassingen door te voeren en te testen op de clone zonder dat deze de productieomgeving beïnvloeden. Bij creatie nemen clones geen extra ruimte in, aangezien ze gelijk zijn aan de snapshot waarop ze gebaseerd zijn. Als er aanpassingen aan de clone worden gedaan, dan wordt er echter wel extra opslagruimte aangewend \autocite{Lucas2015}.

Het concept van snapshots en clones valt het best te vergelijken met die van branches in bijvoorbeeld een versiebeheersysteem zoals git: de snapshot is de master branch, de clone is een aftakking van deze master branch. Er moet wel opgemerkt worden dat clones geen updates ontvangen van het bestandssysteem waarvan de snapshot werd genomen; indien nodig moeten er dus een nieuwe snapshot en dus ook een nieuwe clone worden aangemaakt \autocite{Lucas2015}.

Om een clone van een snapshot aan te maken, gebruikt men het commando \texttt{zfs clone <snapshot> <nieuwe\_dataset>}:

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs clone storage/projects/www@www_16-05-2017 storage/projects/www_new
  $ zfs list
  NAME                        USED  AVAIL  REFER  MOUNTPOINT
  storage                    20.6G   877G   133K  /storage
  storage/projects           20.6G   877G   144K  /storage/projects
  storage/projects/dev        128K   877G   128K  /storage/projects/dev
  storage/projects/vol_test  20.6G   898G  3.43M  -
  storage/projects/www        128K   877G   128K  /storage/projects/www
  storage/projects/www_new   10.7K   877G   128K  /storage/projects/www_new
\end{lstlisting}

Uit de output van \texttt{zfs list} kan worden afgeleid dat er inderdaad een nieuwe dataset werd aangemaakt met de naam \texttt{www\_new}. Deze nieuwe dataset en de oorspronkelijke snapshot zijn aan elkaar gekoppeld. 

Om de relatie tussen een snapshot en zijn kloon of klonen te bekijken, kunnen de betreffende properties van de clone worden opgehaald. Uit onderstaande uitvoer kan worden afgeleid dat de clone gebaseerd is op de snapshot \texttt{storage/projects/www@www\_16-05-2017}.

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs get origin /storage/projects/www_new
  NAME                      PROPERTY  VALUE                                SOURCE
  storage/projects/www_new  origin    storage/projects/www@www_16-05-2017  -
\end{lstlisting}

Om een clone te 'upgraden' of te promoveren tot een volwaardige dataset die volledig op zichzelf staat, gebruik je het commando \texttt{zfs promoto <naam clone>}:

\begin{lstlisting}[language=bash,style=command_style] 
  $ zfs promote storage/projects/www_new
  $ zfs get origin /storage/projects/www_new
  NAME                      PROPERTY  VALUE   SOURCE
  storage/projects/www_new  origin    -       -
\end{lstlisting}

De waarde van de property 'origin' is leeg, wat aanduidt dat de dataset niet meer afhangt van de snaphot \texttt{istorage/projects/www@www\_16-05-2017}. 







